  - content
    - csharp
      - CAFSln
        - .build
          - assets
        - .github
          - workflows
        - .template.config
          - build
          - console
          - sln
        - src
          - CAFConsole
            - Commands
            - Configuration
            - Filters
            - Logging
            - Properties
            - Services
          - CAFConsole.Data
            - Services
            - Sqlite
          - CAFConsole.Lib
          - CAFConsole.Tests
    - powershell

# --- Start of Code Files ---


// File: templates\content\csharp\CAFSln\.build\targets.cs`$lang#!/usr/bin/dotnet run

#:package McMaster.Extensions.CommandLineUtils@4.1.1
#:package Bullseye@6.0.0
#:package SimpleExec@12.0.0

using Bullseye;
using McMaster.Extensions.CommandLineUtils;
using static Bullseye.Targets;
using static SimpleExec.Command;

using var app = new CommandLineApplication { UsePagerForHelpText = false };
app.HelpOption();

var ridOption = app.Option<string>(
    "--rid <rid>",
    "The runtime identifier (RID) to use for publishing.",
    CommandOptionType.SingleValue
);
var versionOption = app.Option<string>(
    "--version <version>",
    "The release version.",
    CommandOptionType.SingleValue
);

app.Argument(
    "targets",
    "A list of targets to run or list. If not specified, the \"default\" target will be run, or all targets will be listed.",
    true
);
foreach (var (aliases, description) in Options.Definitions)
{
    _ = app.Option(string.Join("|", aliases), description, CommandOptionType.NoValue);
}

app.OnExecuteAsync(async _ =>
{
    const string configuration = "Release";
    const string solution = "CAFConsole.slnx";
    const string publishProject = null!; // = "src/CAFConsole/CAFConsole.csproj";
    const string packProject = null!; // = "src/CAFConsole.Lib/CAFConsole.Lib.csproj";

    var root = Directory.GetCurrentDirectory();

    var targets = app.Arguments[0].Values.OfType<string>();
    var options = new Options(
        Options.Definitions.Select(d =>
            (
                d.Aliases[0],
                app.Options.Single(o => d.Aliases.Contains($"--{o.LongName}")).HasValue()
            )
        )
    );

    Target("clean", () => RunAsync("dotnet", $"clean {solution} --configuration {configuration}"));

    Target(
        "restore",
        () =>
        {
            var rid = ridOption.Value();
            var runtimeArg = !string.IsNullOrEmpty(rid) ? $"--runtime {rid}" : string.Empty;
            return RunAsync("dotnet", $"restore {solution} {runtimeArg}");
        }
    );

    Target(
        "build",
        ["restore"],
        () => RunAsync("dotnet", $"build {solution} --configuration {configuration} --no-restore")
    );

    Target(
        "test",
        ["build"],
        async () =>
        {
            var testResultFolder = "TestResults";
            var coverageFileName = "coverage.xml";
            var testResultPath = Directory.CreateDirectory(Path.Combine(root, testResultFolder));
            await RunAsync(
                "dotnet",
                $"test --solution {solution} --configuration {configuration} --coverage --coverage-output {Path.Combine(testResultPath.FullName, coverageFileName)} --coverage-output-format xml --ignore-exit-code 8"
            );
        }
    );

    Target("default", ["build"], () => Console.WriteLine("Default target ran."));

    Target(
        "publish",
        () =>
        {
            var rid = ridOption.Value();
            ArgumentException.ThrowIfNullOrWhiteSpace(rid, nameof(rid));
            var runtimeArg = $"--runtime {rid}";

            var publishDir = Path.Combine(root, "dist", "publish", rid);
            if (Directory.Exists(publishDir))
                Directory.Delete(publishDir, true);

            return RunAsync(
                "dotnet",
                $"publish {publishProject} -c {configuration} -o {publishDir} {runtimeArg}"
            );
        }
    );

    Target(
        "pack",
        dependsOn: ["build"],
        async () =>
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(packProject);

            var nugetOutputDir = Path.Combine(root, "dist", "nuget");

            await RunAsync(
                "dotnet",
                $"pack {packProject} -c {configuration} -o {nugetOutputDir} --no-build"
            );

            var files = Directory.GetFiles(nugetOutputDir, "*.nupkg");
            if (files.Length == 0)
            {
                throw new InvalidOperationException("No NuGet package was created.");
            }
            foreach (var file in files)
            {
                Console.WriteLine($"NuGet package created: {file}");
            }
        }
    );

    Target(
        "release",
        ["publish"],
        () =>
        {
            const string velopackId = "typical";
            var version = versionOption.Value();
            ArgumentException.ThrowIfNullOrWhiteSpace(version, nameof(version));
            var rid = ridOption.Value();
            ArgumentException.ThrowIfNullOrWhiteSpace(rid, nameof(rid));

            var publishDir = Path.Combine(root, "dist", "publish", rid);
            var outputDir = Path.Combine(root, "dist", "release", rid);
            if (Directory.Exists(outputDir))
                Directory.Delete(outputDir, true);
            string directive =
                rid.StartsWith("linux", StringComparison.OrdinalIgnoreCase) ? "[linux]"
                : rid.StartsWith("osx", StringComparison.OrdinalIgnoreCase) ? "[osx]"
                : "[win]";
            return RunAsync(
                "dotnet",
                $"vpk {directive} pack --packId {velopackId} --packVersion {version} --packDir \"{publishDir}\" --outputDir \"{outputDir}\" --yes"
            );
        }
    );

    await RunTargetsAndExitAsync(targets, options);
});

return await app.ExecuteAsync(args);

```
// File: templates\content\csharp\CAFSln\.github\workflows\ci.yml`$lang# .github/workflows/ci.yml
name: Continuous Integration

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        global-json-file: global.json

    - name: Restore .NET tools
      run: dotnet tool restore

    - name: Run Tests
      run: dotnet run .build/targets.cs test

    - name: Upload test results
      if: always() # Run this step even if tests fail
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}
        path: TestResults/

```
// File: templates\content\csharp\CAFSln\.github\workflows\release-nuget.yml`$langname: Publish Stable Nuget

on:
  push:
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'

permissions:
  contents: write

jobs:
  release-nuget:
    name: Publish NuGet Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json
      - name: Run Tests
        run: dotnet run .build/targets.cs test
      - name: Pack NuGet Package
        run: dotnet run .build/targets.cs pack
      # - name: Push NuGet Package
      #   run: dotnet nuget push "dist/nuget/*.nupkg" --api-key ${{ secrets.NUGET_API_KEY }} --source "https://api.nuget.org/v3/index.json" --skip-duplicate

```
// File: templates\content\csharp\CAFSln\.github\workflows\release.yml`$langname: Publish Stable Release

on:
  push:
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'

permissions:
  contents: write

jobs:
  create-release:
    name: Create or Find GitHub Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.get_or_create_release.outputs.upload_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get or Create Release
        id: get_or_create_release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if UPLOAD_URL=$(gh release view ${{ github.ref_name }} --json uploadUrl --jq .uploadUrl 2>/dev/null); then
            echo "Release already exists. Using existing upload URL."
          else
            echo "Release does not exist. Creating a new one."
            # Create the release and capture its upload_url from the output.
            UPLOAD_URL=$(gh release create ${{ github.ref_name }} \
                          --title "Release ${{ github.ref_name }}" \
                          --notes "Automated release created by GitHub Actions." \
                          --draft | grep -oP 'https://uploads.github.com/repos/.*/releases/.*/assets' )
          fi
          echo "Setting output: upload_url=$UPLOAD_URL"
          echo "upload_url=$UPLOAD_URL" >> $GITHUB_OUTPUT
  build-and-upload:
    name: Build & Upload for ${{ matrix.rid }}
    needs: create-release # Depends on the release placeholder being created.
    runs-on: ${{ matrix.runner_os }}
    strategy:
      matrix:
        include:
          - { runner_os: ubuntu-latest, rid: linux-x64, os_name: linux }
          - { runner_os: windows-latest, rid: win-x64, os_name: win }
          - { runner_os: macos-latest, rid: osx-x64, os_name: osx }
      fail-fast: false
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with: { fetch-depth: 0 }
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        global-json-file: global.json
        dotnet-version: '9.0.x'
    - name: Restore .NET tools
      run: dotnet tool restore
    - name: Get version
      id: minver
      shell: bash
      run: |
        VERSION_OUTPUT=$(dotnet minver --default-pre-release-identifiers preview --verbosity error)
        echo "Discovered version: $VERSION_OUTPUT"
        echo "package_version=$VERSION_OUTPUT" >> $GITHUB_OUTPUT
      env:
        DOTNET_NOLOGO: true
    - name: Build Release for ${{ matrix.rid }}
      run: dotnet run .build/targets.cs release --rid ${{ matrix.rid }} --version ${{ steps.minver.outputs.package_version }}
    - name: Upload Release Assets
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Define the path to the release directory and the assets file
        RELEASE_DIR="dist/release/${{ matrix.rid }}"
        ASSETS_FILE="$RELEASE_DIR/assets.${{ matrix.os_name }}.json"
        echo "Looking for assets file at: $ASSETS_FILE"
        cd "$RELEASE_DIR"
        ASSET_LIST=$(jq -r '.[] | select(.Type=="Installer" or .Type=="Portable") | .RelativeFileName' "assets.${{ matrix.os_name }}.json")
        if [ -z "$ASSET_LIST" ]; then
          echo "Warning: No Installer or Portable assets found in $ASSETS_FILE. Nothing to upload."
        else
          echo "Found assets to upload:"
          echo "$ASSET_LIST"
          echo "$ASSET_LIST" | tr -d '\r' | xargs gh release upload ${{ github.ref_name }} --clobber
        fi

```
// File: templates\content\csharp\CAFSln\.template.config\build\template.json`$lang{
    "$schema": "http://json.schemastore.org/template",
    "author": "henry-js",
    "classifications": [
        "Build",
        "CI/CD"
    ],
    "identity": "henry-js.CAF.Build",
    "name": "ConsoleAppFramework Build System",
    "shortName": "cafbuild",
    "sourceName": "CAFConsole",
    "description": "Scaffold a build system for common projects",
    "tags": {
        "language": "C#",
        "type": "item"
    },
    "sources": [
        {
            "source": "../",
            "target": "./",
            "include": [
                ".build/**/*",
                ".config/dotnet-tools.json",
                ".github/**/*",
                ".editorconfig",
                "dotnet.config",
                "build.*"
            ],
            "exclude": [
                "**/[Bb]in/**",
                "**/[Oo]bj/**",
                ".template.config/**/*",
                "**/*.filelist",
                "**/*.user",
                "**/*.lock.json",
                "[Ss]rc/**"
            ]
        }
    ]
}

```
// File: templates\content\csharp\CAFSln\.template.config\console\template.json`$lang{
  "$schema": "https://json.schemastore.org/template",
  "author": "henry-js",
  "classifications": [
    "Common",
    "Console"
  ],
  "name": "ConsoleAppFramework Console",
  "description": "Scaffold a ConsoleAppFramework console application",
  "precedence": "0",
  "identity": "henry-js.CAF.Console",
  "shortName": "cafc",
  "sourceName": "CAFConsole",
  "tags": {
    "language": "C#",
    "type": "project"
  },
  "preferNameDirectory": true,
  "sources": [
    {
      "source": "../src/CAFConsole/",
      "target": "./"
    }
  ],
  "symbols": {
    "IsSolution": {
      "type": "computed",
      "value": "false",
      "datatype": "bool"
    }
  }
}

```
// File: templates\content\csharp\CAFSln\.template.config\sln\template.json`$lang{
    "$schema": "http://json.schemastore.org/template",
    "author": "henry-js",
    "classifications": [
        "Solution"
    ],
    "name": "ConsoleAppFramework Solution",
    "description": "Standardized project structure for a CLI sln",
    "identity": "henry-js.CAF.Solution",
    "shortName": "cafsln",
    "tags": {
        "language": "C#",
        "type": "solution"
    },
    "guids": [
        "A94D195E-48BF-48FF-93B2-D552C966323D",
        "351F6972-61B5-4676-9E74-F376ACA883C8",
        "8C43405D-427E-424E-A4F5-489D19EF1F7B"
    ],
    "sourceName": "CAFConsole",
    "symbols": {
        "IsSolution": {
            "type": "computed",
            "value": "true",
            "datatype": "bool"
        },
        "withDataAccess": {
            "type": "parameter",
            "datatype": "bool",
            "displayName": "Include Data Access Layer",
            "description": "If true, scaffolds a CAFConsole.Data project with Entity Framework Core and SQLite.",
            "defaultValue": "false"
        }
    },
    "sources": [
        {
            "source": "../",
            "target": "./",
            "exclude": [
                "**/[Bb]in/**",
                "**/[Oo]bj/**",
                ".template.config/**/*",
                "**/*.filelist",
                "**/*.user",
                "**/*.lock.json",
                "**/*.dist",
                "**/.vs/**",
                "**/.artifacts/**",
                "src/CAFConsole.Data/**"
            ],
            "modifiers": [
                {
                    "condition": "(!withDataAccess)",
                    "exclude": [
                        "ef.rsp"
                    ]
                }
            ]
        },
        {
            "source": "../src/CAFConsole.Data/",
            "target": "./src/CAFConsole.Data/",
            "condition": "(withDataAccess)"
        }
    ]
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Commands\MyCommands.cs`$langusing System.Text.Json;
using CAFConsole.Configuration;
using CAFConsole.Data.Sqlite;
using CAFConsole.Services;
using ConsoleAppFramework;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CAFConsole.Commands;

public class MyCommands(
    ILogger<MyCommands> logger,
    IService service,
    IOptions<CAFConsoleSettings> options,
    AppDbContext dbContext
)
{
    private readonly CAFConsoleSettings config = options.Value;

    /// <summary>Root command test.</summary>
    /// <param name="msg">-m, Message to show.</param>
    [Command("")]
    public void Root(string msg)
    {
        logger.LogInformation($"Hello from logger");
        service.DoSomething();
        Console.WriteLine(msg);
    }

    /// <summary>Display message.</summary>
    /// <param name="msg">Message to show.</param>
    public void Echo(string msg) => Console.WriteLine(msg);

    /// <summary>Sum parameters.</summary>
    /// <param name="x">left value.</param>
    /// <param name="y">right value.</param>
    public void Sum(int x, int y) => Console.WriteLine(x + y);

    [Command("config")]
    public void Config()
    {
        var opts = options;
        logger.LogInformation("Displaying IOptions wrapped config");

        var text = JsonSerializer.Serialize(config, typeof(CAFConsoleSettings), CAFConsoleSettingsContext.Default);

        Console.WriteLine(text);
    }

    /// <summary>
    /// Applies any pending Entity Framework migrations to the database.
    /// </summary>
    [Command("migrate-db")]
    public async Task MigrateDatabase()
    {
        logger.LogInformation("Checking for and applying pending database migrations...");

        var pendingMigrations = await dbContext.Database.GetPendingMigrationsAsync();
        if (!pendingMigrations.Any())
        {
            logger.LogInformation("Database is already up to date. No migrations to apply.");
            return;
        }

        await dbContext.Database.MigrateAsync();

        logger.LogInformation("Successfully applied all pending migrations.");
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Configuration\CAFConsoleSettings.cs`$langusing System.Text.Json.Serialization;

namespace CAFConsole.Configuration;

public class CAFConsoleSettings
{
    public int Port { get; set; }
    public bool Enabled { get; set; }
    public string? ApiUrl { get; set; }
}

[JsonSourceGenerationOptions(
    WriteIndented = true,
    AllowTrailingCommas = true,
    UseStringEnumConverter = true,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    PropertyNameCaseInsensitive = true
)]
[JsonSerializable(typeof(CAFConsoleSettings))]
public partial class CAFConsoleSettingsContext : JsonSerializerContext;

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Filters\ExceptionFilter.cs`$langusing ConsoleAppFramework;
using Microsoft.Extensions.Logging;
using Spectre.Console;

namespace CAFConsole.Filters;

internal sealed class ExceptionFilter(ConsoleAppFilter next, ILoggerFactory factory)
    : ConsoleAppFilter(next)
{
    public override async Task InvokeAsync(
        ConsoleAppContext context,
        CancellationToken cancellationToken
    )
    {
        var logger = factory.CreateLogger("Program");

        try
        {
            await Next.InvokeAsync(context, cancellationToken);
        }
        catch (Exception ex)
        {
            AnsiConsole.MarkupLineInterpolated($"[red]{ex.Message}[/]");
            logger.LogError(ex, "Program stopped");
        }
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Logging\SourceClassEnricher.cs`$langusing Serilog.Core;
using Serilog.Events;

namespace CAFConsole.Logging;

public class SourceClassEnricher : ILogEventEnricher
{
    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
    {
        if (
            logEvent.Properties.TryGetValue("SourceContext", out var value)
            && value is ScalarValue sv
            && sv.Value is string fullName
        )
        {
            var shortName = fullName.Split('.').Last();
            var property = propertyFactory.CreateProperty("SourceClass", shortName);
            logEvent.AddOrUpdateProperty(property);
        }
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Properties\launchSettings.json`$lang{
    "profiles": {
        "CAFConsole": {
            "commandName": "Project",
            "commandLineArgs": "",
            "workingDirectory": "..\\"
        }
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Services\IService.cs`$langnamespace CAFConsole.Services;

public interface IService
{
    void DoSomething();
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Services\ServiceExtensions.cs`$langusing CAFConsole.Commands;
using CAFConsole.Data;
using CAFConsole.Data.Services;
using CAFConsole.Logging;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Serilog;
using Serilog.Events;
using Serilog.Formatting.Display;
using Serilog.Sinks.SystemConsole.Themes;

namespace CAFConsole.Services;

public static class ServiceExtensions
{
    public static IConfiguration CreateConfiguration()
    {
        var configBuilder = new ConfigurationBuilder().AddJsonFile(
            "config.json",
            optional: false,
            reloadOnChange: true
        );

#if (withDataAccess)
        configBuilder.AddJsonFile("sqlitedb.json", optional: false, reloadOnChange: true);
#endif

        return configBuilder.Build();
    }

    public static void ConfigureSerilog(this ILoggingBuilder builder)
    {
        const string outputTemplate =
            "[{Timestamp:HH:mm:ss} {Level:u3}] ({SourceClass}) {Message:lj}{NewLine}{Exception}";
        builder.AddSerilog(
            new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(
                    formatter: new MessageTemplateTextFormatter(outputTemplate),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "logs", "app-.log"),
                    restrictedToMinimumLevel: LogEventLevel.Debug,
                    shared: true,
                    rollingInterval: RollingInterval.Day
                )
                .Enrich.WithProperty("ApplicationName", "<APP NAME>")
                .Enrich.With<SourceClassEnricher>()
                .WriteTo.Console(
                    outputTemplate: outputTemplate,
                    theme: AnsiConsoleTheme.Sixteen,
                    restrictedToMinimumLevel: LogEventLevel.Information
                )
                .CreateLogger()
        );
    }

    public static IServiceCollection RegisterAppServices(this IServiceCollection services)
    {
        var configuration = CreateConfiguration();

        services.AddLogging(ConfigureSerilog);
        services.AddSingleton(configuration);
        services.AddSingleton<IService, ServiceImplementation>();
        services.AddSingleton<MyCommands>();

#if (withDataAccess)
        var databaseOptions = configuration
            .GetSection(DatabaseOptions.SectionName)
            .Get<DatabaseOptions>();

        databaseOptions.FilePath = Path.Combine(
            AppConstants.DataDirectory,
            databaseOptions.FileName
        );

        services.AddSqliteDb(databaseOptions);
#endif

        return services;
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Services\ServiceImplementation.cs`$langusing Microsoft.Extensions.Logging;

namespace CAFConsole.Services;

public class ServiceImplementation(ILogger<ServiceImplementation> logger) : IService
{
    public void DoSomething()
    {
        logger.LogCritical("I am doing something");
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\config.json`$lang{
    "CAFConsoleSettings": {
        "Port": "5001",
        "Enabled": true,
        "ApiUrl": "https://jsonplaceholder.typicode.com/"
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Constants.cs`$langnamespace CAFConsole;

public static class AppConstants
{
    public static string AppName => "CAFConsole";

    // Centralize the logic for getting the data directory
    public static string DataDirectory =>
        Path.Combine(Xdg.Directories.BaseDirectory.DataHome, AppName.ToLower());

    // Centralize the logic for the full database file path
}

public static class AppInitializer
{
    /// <summary>
    /// Performs first-run and every-run initializations for the application.
    /// This method is idempotent and safe to call on every application startup.
    /// </summary>
    public static void Initialize()
    {
        // 1. Ensure the application's data directory exists in the user's profile.
        //    This is the most critical step.
        if (!Directory.Exists(AppConstants.DataDirectory))
        {
            Directory.CreateDirectory(AppConstants.DataDirectory);
        }

        // 2. Handle any other necessary file creation.
        //    For EF Core with SQLite, the database provider will create the .db file
        //    automatically on first connection if it doesn't exist. Therefore,
        //    you usually don't need to create the file itself, just the directory.

        // Example: If you needed to create a default config file if one didn't exist:
        // var userConfigPath = Path.Combine(AppConstants.DataDirectory, "user.json");
        // if (!File.Exists(userConfigPath))
        // {
        //     File.WriteAllText(userConfigPath, "{}");
        // }
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\Program.cs`$langusing CAFConsole;
using CAFConsole.Commands;
using CAFConsole.Filters;
using CAFConsole.Services;
using ConsoleAppFramework;
using DotNetPathUtils;
using Microsoft.Extensions.DependencyInjection;
using Velopack;

if (OperatingSystem.IsWindows())
{
    var appDirectory = Path.GetDirectoryName(AppContext.BaseDirectory)!;
    var pathHelper = new PathEnvironmentHelper(new PathUtilsOptions() { PrefixWithPeriod = false });
    VelopackApp
        .Build()
        .OnAfterInstallFastCallback(v => pathHelper.EnsureDirectoryIsInPath(appDirectory))
        .OnBeforeUninstallFastCallback(v => pathHelper.RemoveDirectoryFromPath(appDirectory!))
        .Run();
}

AppInitializer.Initialize();

var services = new ServiceCollection();

services.RegisterAppServices();
ConsoleApp.ServiceProvider = services.BuildServiceProvider();

var app = ConsoleApp.Create();

app.Add<MyCommands>();

app.UseFilter<ExceptionFilter>();

await app.RunAsync(args);

#if DEBUG
Console.WriteLine("Press any key to exit...");
Console.ReadKey();
#endif

```
// File: templates\content\csharp\CAFSln\src\CAFConsole\sqlitedb.json`$lang{
    "Database": {
        "FileName": "app.db"
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole.Data\Services\ServiceExtensions.cs`$langusing CAFConsole.Data.Sqlite;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

namespace CAFConsole.Data.Services;

public static class ServiceExtensions
{
    public static IServiceCollection AddSqliteDb(
        this IServiceCollection services,
        DatabaseOptions databaseOptions
    )
    {
        if (databaseOptions is null || string.IsNullOrEmpty(databaseOptions.FilePath))
        {
            throw new InvalidOperationException(
                $"The '{DatabaseOptions.SectionName}' configuration section is missing or the 'DbPath' is empty."
            );
        }

        var finalConnectionString = new SqliteConnectionStringBuilder
        {
            DataSource = databaseOptions.FilePath,
        }.ToString();

        services.AddDbContext<AppDbContext>(options => options.UseSqlite(finalConnectionString));
        return services;
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole.Data\Sqlite\AppDbContext.cs`$langusing System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;

namespace CAFConsole.Data.Sqlite;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options) { }

    // Add your DbSets here. For example:
    public DbSet<MyEntity> MyEntities { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
    }
}

public class MyEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = default!;
}

public class AppDbContextFactory : IDesignTimeDbContextFactory<AppDbContext>
{
    public AppDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<AppDbContext>();

        // This connection string is used only for design-time tooling,
        // like creating migrations. It does not need to be the same
        // as the one used at runtime.
        optionsBuilder.UseSqlite("Data Source=design_time.db");

        return new AppDbContext(optionsBuilder.Options);
    }
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole.Data\Sqlite\DatabaseOptions.cs`$langnamespace CAFConsole.Data;

public class DatabaseOptions
{
    /// <summary>
    /// The configuration section name for these options.
    /// </summary>
    public const string SectionName = "Database";

    /// <summary>
    /// The name of the database file (e.g., "app.db").
    /// </summary>
    public string FileName { get; set; } = string.Empty;
    public string FilePath { get; set; } = string.Empty;
}

```
// File: templates\content\csharp\CAFSln\src\CAFConsole.Lib\Class1.cs`$langnamespace CAFConsole.Lib;

public class Class1 { }

```
// File: templates\content\csharp\CAFSln\src\CAFConsole.Tests\Tests.cs`$langnamespace CAFConsole.Tests;

public class Tests
{
    [Test]
    public void Basic()
    {
        Console.WriteLine("This is a basic test");
    }

    [Test]
    [Arguments(1, 2, 3)]
    [Arguments(2, 3, 5)]
    public async Task DataDrivenArguments(int a, int b, int c)
    {
        Console.WriteLine("This one can accept arguments from an attribute");

        var result = a + b;

        await Assert.That(result).IsEqualTo(c);
    }

    [Test]
    [MethodDataSource(nameof(DataSource))]
    public async Task MethodDataSource(int a, int b, int c)
    {
        Console.WriteLine("This one can accept arguments from a method");

        var result = a + b;

        await Assert.That(result).IsEqualTo(c);
    }

    public static IEnumerable<(int a, int b, int c)> DataSource()
    {
        yield return (1, 1, 2);
        yield return (2, 1, 3);
        yield return (3, 1, 4);
    }
}

```
// File: templates\content\csharp\CAFSln\build.ps1`$langdotnet run .build/targets.cs -- $args

```
// File: templates\content\csharp\CAFSln\build.sh`$lang#!/usr/bin/env bash

# Exit immediately if a command exits with a non-zero status.
set -e

# This script is a simple wrapper around the C# build script.
# It passes all command-line arguments directly to the script.
# The '--' separates arguments for 'dotnet run' from arguments for the application.
dotnet run .build/targets.cs -- "$@"

```
